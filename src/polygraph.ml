(** Operations on polygraphs. *)

(* TODO: Once it is stabilized, we could remove source / target arguments from
functions and only keep maps which would be nicer. Similarly, we only need
c_source_morphism and not c_source (and similarly for target) for cells. *)

open Core

module Equivq = Mapq.Equiv

(** A generator. The way to compare generators is physical equality. *)
type generator =
    {
      g_dim : int;
      g_name : string; (** name of the generator, only used for printing purposes *)
      g_source : cell; (** source (n-1)-cell *)
      g_target : cell; (** target (n-1)-cell *)
    }

 (** A polygraph. *)
 and polygraph =
   {
     p_dim : int;
     p_generators : generator list; (** n-dimensional generators whose source and target are labeled in the underlying (n-1)-polygraph *)
     p_prev : polygraph; (** underlying (n-1)-dimensional polygraph *)
   }

 (** A morphism between polygraphs. *)
 and morphism =
   {
     m_map : (generator,generator) Mapq.t; (** function between top-dimensional generators *)
     m_prev : morphism; (** morphism between lower-dimensional cells *)
     m_source : polygraph; (** source of the map *)
     m_target : polygraph; (** target of the map *)
   }

 (** A cell in a free n-category generated by a polygraph. *)
 and cell =
   {
     c_label : morphism; (** labeling morphism for the polygraph of the cell *)
     c_source : cell; (** source (n-1)-cell *)
     c_source_morphism : morphism; (** inclusion of the polygraph of the source cell into the polygraph of the cell *)
     c_target : cell; (** target (n-1)-cell *)
     c_target_morphism : morphism; (** inclusion of the polygraph of the target cell into the polygraph of the cell *)
   }


(** {2 Accessors} *)

(** {3 Generators} *)

let g_dim g = g.g_dim

let g_name g = g.g_name

let g_source g = g.g_source

let g_target g = g.g_target

(** {3 Polygraphs} *)

let p_dim p = p.p_dim

let p_generators p = p.p_generators

let p_prev p = p.p_prev

(** {3 Morphisms} *)

let m_map f = f.m_map

let m_prev f = f.m_prev

let m_source f = f.m_source

let m_target f = f.m_target

let m_dim f = p_dim (m_source f)

(** {3 Cells} *)

let c_label c = c.c_label

let c_polygraph c = m_source (c_label c)

let c_dim c = p_dim (c_polygraph c)

let c_source c = c.c_source

let c_source_morphism c = c.c_source_morphism

let c_target c = c.c_target

let c_target_morphism c = c.c_target_morphism

(** Image of a generator under a map. *)
let m_app f gen =
  assert (m_dim f = g_dim gen);
  Mapq.app (m_map f) gen

(** {2 Comparison} *)

(** Equality between polygraphs. *)
let rec p_eq p1 p2 =
  assert (p_dim p1 = p_dim p2);
  p1 == p2
  || (
    p_dim p1 = p_dim p2
    && Listq.equiv (p_generators p1) (p_generators p2)
    && p_eq (p_prev p1) (p_prev p2)
  )

(** {2 Creation} *)

(** {3 Generators} *)

let g_create ~name ~source ~target () =
  assert (c_dim source = c_dim target);
  let dim = c_dim source + 1 in
  {
    g_dim = dim;
    g_name = name;
    g_source = source;
    g_target = target;
  }

(** {3 Polygraphs} *)

let rec p_dummy =
  {
    p_dim = -1;
    p_generators = [];
    p_prev = p_dummy;
  }

(** Add a new generator to a polygraph. *)
let p_add p g =
  assert (p_dim p >= 0);
  assert (p_dim p = g_dim g);
  assert (not (Listq.mem g (p_generators p)));
  let p = { p with p_generators = g::(p_generators p) } in
  p

let p_degenerate p =
  {
    p_dim = p_dim p + 1;
    p_prev = p;
    p_generators = [];
  }

(** Create a new polygraph. It is better to use [p_add] instead. *)
let p_create ~generators ~prev () =
  List.fold_left p_add (p_degenerate prev) generators

(** {3 Morphisms} *)

let rec m_dummy =
  {
    m_map = Mapq.empty;
    m_prev = m_dummy;
    m_source = p_dummy;
    m_target = p_dummy;
  }

(** {3 Cells} *)

let c_create ~label ~source ~source_morphism ~target ~target_morphism () =
  let dim = m_dim label in
  let polygraph = m_source label in
  assert (c_dim source + 1 = dim);
  assert (c_dim target + 1 = dim);
  assert (m_dim source_morphism = dim);
  assert (m_dim target_morphism = dim);
  assert (p_eq (p_prev (m_source source_morphism)) (c_polygraph source));
  assert (p_eq (p_prev (m_source target_morphism)) (c_polygraph target));
  assert (p_eq (m_target source_morphism) polygraph);
  assert (p_eq (m_target target_morphism) polygraph);
  {
    c_label = label;
    c_source = source;
    c_source_morphism = source_morphism;
    c_target = target;
    c_target_morphism = target_morphism;
  }

let rec c_dummy =
  {
    c_label = m_dummy;
    c_source = c_dummy;
    c_source_morphism = m_dummy;
    c_target = c_dummy;
    c_target_morphism = m_dummy;
  }

(** {2 String representation} *)

(** Unique identifier for generators wrt physical equality. *)
module UID = struct
  include UID.Named

  let get uid g = get uid (g_name g) g

  let string uid g =
    g_name g ^ string_of_int (get uid g)

  let string ?label uid g =
    match label with
    | Some label ->
       string uid g ^ "(" ^ string uid label ^ ")"
    | None ->
       string uid g
end

module String = struct
  include String

  let tabs n = String.make (2*n) ' '
end

(** UID generator used for debugging. *)
let uidebug : generator UID.t = UID.create ()

(** Convert a 1-cell to a list *)
let c_list_of_one_cell c =
  assert (c_dim c = 1);
  let p = c_polygraph c in
  let element c = List.element (p_generators (c_polygraph c)) in
  let s = element (c_source c) in
  let t = element (c_target c) in
  let s = m_app (m_prev (c_source_morphism c)) s in
  let t = m_app (m_prev (c_target_morphism c)) t in
  let ll = ref [] in
  let t = ref t in
  let rec aux () =
    if !t != s then
      let g =
        Listq.find
          (fun g ->
           let gt = element (g_target g) in
           let gt = m_app (c_label (g_target g)) gt in
           gt == !t
          ) (p_generators p)
      in
      ll := (g,!t) :: !ll;
      t := m_app (c_label (g_source g)) (List.element (p_generators (c_polygraph (g_source g))));
      aux ()
  in
  aux ();
  s, !ll

(** String representation of a generator. *)
let rec g_to_string ?(tab=0) ?(human=true) ?label uid g =
  let label = match label with Some label -> Some (m_app label g) | None -> None in
  UID.string ?label uid g

(** String representation of a polygraph. *)
and p_to_string ?(tab=0) ?(human=true) ?label uid p =
  Option.may (fun label -> assert (m_dim label = p_dim p)) label;
  let global_label = label in
  let g_to_string ?(tab=tab) ?(human=human) ?label uid g =
    let label = match label with Some _ -> label | None -> global_label in
    g_to_string ~tab ~human ?label uid g
  in
  let p_to_string ?(tab=tab) ?(human=human) ?label uid p =
    let label = match label with Some _ -> label | None -> global_label in
    p_to_string ~tab ~human ?label uid p
  in
  let c_to_string ?(tab=tab) ?(human=human) uid c = c_to_string ~tab ~human uid c in
  let tabs = String.tabs tab in
  let dim = p_dim p in
  if dim < 0 then (* tabs ^ "- dim ⊥\n" *) ""
  else if dim = 0 then
    Printf.sprintf "%sdim 0:\n%s  %s\n" tabs tabs (String.concat_map " " (fun g -> g_to_string uid g) (p_generators p))
  else if dim = 1 then
    let gs g =
      let source = g_source g in
      let target = g_target g in
      let source = List.element (p_generators (c_polygraph source)) in
      let target = List.element (p_generators (c_polygraph target)) in
      Printf.sprintf
        "%s  %s : %s → %s\n"
        tabs
        (g_to_string uid g)
        (g_to_string ~label:(c_label (g_source g)) uid source)
        (g_to_string ~label:(c_label (g_target g)) uid target)
    in
    Printf.sprintf "%s%sdim %d:\n%s" (p_to_string ?label:(Option.funct m_prev label) uid (p_prev p)) tabs dim (String.concat_map "" gs (p_generators p))
  else if human && dim = 2 then
    let gs g =
      let source = g_source g in
      let target = g_target g in
      Printf.sprintf
        "%s  %s : %s ⇒ %s\n"
        tabs
        (g_to_string uid g)
        (c_to_string ~tab:0 uid source)
        (c_to_string ~tab:0 uid target)
    in
    Printf.sprintf "%s%sdim 2:\n%s" (p_to_string ?label:(Option.funct m_prev label) uid (p_prev p)) tabs (String.concat_map "" gs (p_generators p))
  else
    let gs g =
      String.tabs (tab+1) ^ g_to_string uid g ^ ":\n"
      ^ c_to_string ~tab:(tab+2) uid (g_source g)
      ^ String.tabs (tab+1) ^ "to\n"
      ^ c_to_string ~tab:(tab+2) uid (g_target g)
    in
    Printf.sprintf "%s%sdim %d:\n" (p_to_string ?label:(Option.funct m_prev label) uid (p_prev p)) tabs dim
    ^ (String.concat_map "" gs (p_generators p))

(** String representation of a cell. *)
and c_to_string ?(tab=0) ?(human=true) uid c =
  let g_to_string ?(tab=tab) ?(human=human) ?label uid g = g_to_string ~tab ~human ?label uid g in
  let p_to_string ?(tab=tab) ?(human=human) = p_to_string ~tab ~human in
  let c_to_string ?(tab=tab) ?(human=human) = c_to_string ~tab ~human in
  let tabs = String.tabs tab in
  let dim = c_dim c in
  if dim < 0 then ""
  else if human && dim = 0 then
    let g = List.element (p_generators (c_polygraph c)) in
    g_to_string ~label:(c_label c) uid g
  else if human && dim = 1 then
    (* let () = Printf.printf "cl1:\n%s\n%!" (c_to_string ~human:false uid c) in *)
    let s, ll = c_list_of_one_cell c in
    let label = c_label c in
    tabs
    ^ g_to_string ~label:(m_prev label) uid s
    ^ String.concat_map
        ""
        (fun (g,t) ->
         Printf.sprintf
           " -%s→ %s"
           (g_to_string ~label uid g)
           (g_to_string ~label:(m_prev label) uid t)
        ) ll
  else
    let tabs' = String.tabs (tab+1) in
    (* TODO: when there are no more bugs, we should only print the sources and
    targets once in each dimension. *)
    Printf.sprintf "%s%d-cell:\n%s" tabs dim (p_to_string ~label:(c_label c) ~tab:(tab+2) uid (c_polygraph c))
    ^ (if dim = 0 then "" else
         Printf.sprintf "%s%d-source:\n%s" tabs' (dim-1) (String.ensure_nl (c_to_string ~tab:(tab+2) uid (c_source c)))
         ^ Printf.sprintf "%s%d-source morphism:\n%s" tabs' (dim-1) (m_to_string ~tab:(tab+2) uid (m_prev (c_source_morphism c)))
         ^ Printf.sprintf "%s%d-target:\n%s" tabs' (dim-1) (String.ensure_nl (c_to_string ~tab:(tab+2) uid (c_target c)))
         ^ Printf.sprintf "%s%d-target morphism:\n%s" tabs' (dim-1) (m_to_string ~tab:(tab+2) uid (m_prev (c_target_morphism c)))
      )

(** String representation of a map between generators. *)
and map_to_string uid f =
  String.concat_map " " (fun (x,y) -> g_to_string uid x ^ "↦" ^ g_to_string uid y) (Mapq.to_list f)

(** String representation of a map. *)
and m_to_string ?(tab=0) uid f =
  let tabs = String.tabs tab in
  if m_dim f < 0 then "" else
    m_to_string ~tab uid (m_prev f) ^ tabs ^ map_to_string uid (m_map f) ^ "\n"

(** {2 Main modules} *)

(** Operations on generators. *)
module Generator = struct
  type t = generator

  let dim = g_dim

  let name = g_name

  let source = g_source

  let target = g_target

  let create = g_create

  let to_string = g_to_string

  module Map = Mapq
end
module G = Generator
module GMap = G.Map

(** Operations on polygraphs. *)
module Polygraph = struct
  type t = polygraph

  let dim = p_dim

  let generators = p_generators

  let prev = p_prev

  let eq = p_eq

  let to_string = p_to_string

  let create = p_create

  let dummy = p_dummy

  (** Does a non-necessarily top-dimensional generator belong to a polygraph. *)
  let memd p g =
    assert (g_dim g <= dim p);
    let rec aux p =
      if dim p = g_dim g then Listq.mem g (generators p)
      else aux (prev p)
    in
    aux p

  (** Add a generator to a polygraph. *)
  let add = p_add

  (** Add multiple generators to a polygraph. *)
  let adds p gg = List.fold_left add p gg

  (** See an n-polygraph as an (n+1)-polygraph. *)
  let degenerate = p_degenerate

  (** Non-disjoint union of two polygraphs. *)
  let rec union p1 p2 =
    assert (dim p1 = dim p2);
    if dim p1 < 0 then dummy else
      let generators = Listq.union (p_generators p1) (p_generators p2) in
      let p' = union (p_prev p1) (p_prev p2) in
      create ~prev:p' ~generators ()

  let p_union = union

  (** Operations on morphisms. *)
  module Morphism = struct
    type t = morphism

    let dim = m_dim

    let map = m_map

    let prev = m_prev

    let source = m_source

    let target = m_target

    let create ~map ~prev ~source ~target () =
      let dim = dim prev + 1 in
      assert (p_dim source = dim);
      assert (p_dim target = dim);
      assert (List.for_all (fun (g1,g2) -> G.dim g1 = dim && G.dim g2 = dim) (GMap.to_list map));
      assert (List.for_all (fun (g1,g2) -> Listq.mem g1 (generators source) && Listq.mem g2 (generators target)) (GMap.to_list map));
      assert (Listq.for_all (GMap.mem map) (generators source));
      {
        m_map = map;
        m_prev = prev;
        m_source = source;
        m_target = target;
      }

    let m_create = create

    let dummy = m_dummy

    let to_string = m_to_string

    let app = m_app

    (** Apply a morphism to a non-necessarily top-dimensional generator. *)
    let appd f g =
      assert (G.dim g <= dim f);
      let rec aux f =
        if dim f = G.dim g then app f g
        else aux (prev f)
      in
      aux f

    (** Inclusion map of a polygraph into another polygraph. *)
    let rec inclusion p1 p2 =
      assert (p_dim p1 = p_dim p2);
      assert (Listq.included (p_generators p1) (p_generators p2));
      if p_dim p1 < 0 then dummy else
        let f' = inclusion (p_prev p1) (p_prev p2) in
        let map = GMap.fold_make (fun g -> g, g) (p_generators p1) in
        create ~map ~prev:f' ~source:p1 ~target:p2 ()

    (** Identity map on a polygraph. *)
    let id p = inclusion p p

    (** Degenerate a morphism. *)
    let degenerate f =
      let source = p_degenerate (source f) in
      let target = p_degenerate (target f) in
      let map = GMap.empty in
      create ~map ~prev:f ~source ~target ()

    (** Sequential composition of two maps. *)
    let rec seq f g =
      assert (dim f = dim g);
      if dim f < 0 then dummy else
        let map = GMap.map (app g) (map f) in
        let prev = seq (prev f) (prev g) in
        let source = source f in
        let target = target g in
        create ~map ~prev ~source ~target ()

    (** Sequential composition of multiple maps. *)
    let rec seqs = function
      | [f] -> f
      | f::ff -> seq f (seqs ff)
      | [] -> assert false

    (** Invert an invertible map. *)
    let rec invert f =
      if dim f < 0 then dummy else
        let map = GMap.op (map f) in
        let prev = invert (prev f) in
        create ~map ~prev ~source:(target f) ~target:(source f) ()

    (** Section of a surjective map. *)
    let section f = invert f

    (** Non-disjoint union of two maps. *)
    let rec union f1 f2 =
      assert (dim f1 = dim f2);
      if dim f1 < 0 then dummy else
        let source = p_union (source f1) (source f2) in
        let target = p_union (target f1) (target f2) in
        let map =
          GMap.of_list
            (List.map
               (fun x ->
                x,
                let y1 = Option.find (app f1) x in
                let y2 = Option.find (app f2) x in
                match y1, y2 with
                | Some y1, Some y2 -> assert (y1 == y2); y1
                | Some y, None | None, Some y -> y
                | None, None -> assert false
               )
               (p_generators source))
        in
        let prev = union (prev f1) (prev f2) in
        create ~map ~prev ~source ~target ()

    (** Universal extension of a pair of cofinal maps on a coproduct. *)
    let rec coprod f1 (i1,i2) f2 =
      (* Printf.printf "MAP COPROD:\nf1:\n%s\ni1:\n%sx:\n%si2:\n%sf2:\n%s\n%!" (to_string uidebug f1) (to_string uidebug i1) (p_to_string uidebug x) (to_string uidebug i2) (to_string uidebug f2); *)
      (* Printf.printf "target f1:\n%s\n%!" (p_to_string uidebug (target f1)); *)
      (* Printf.printf "target f2:\n%s\n%!" (p_to_string uidebug (target f2)); *)
      assert (p_eq (target f1) (target f2));
      assert (p_eq (source f1) (source i1));
      assert (p_eq (source f2) (source i2));
      let source = target i1 in
      let target = target f1 in
      if dim i1 < 0 then dummy else
        let map = GMap.union (GMap.lan (map f1) (map i1)) (GMap.lan (map f2) (map i2)) in
        let prev = coprod (prev f1) (prev i1,prev i2) (prev f2) in
        create ~map ~prev ~source ~target ()

    (** Universal extension of a pair of cofinal maps on a pushout. *)
    let pushout f1 (i1,i2) f2 = coprod f1 (i1,i2) f2

    let bipushout f1 (i1,i2) f2 = coprod f1 (i1,i2) f2

    (** Image of a generator. *)
    let generator f g = app f g

    (** Image of a polygraph. *)
    let rec polygraph f p =
      (* Printf.printf "polygraph image of\n%sby\n%s\n%!" (p_to_string uidebug p) (to_string uidebug f); *)
      assert (dim f = p_dim p);
      if dim f < 0 then p_dummy else
        let generators = Listq.map (fun g -> app f g) (generators p) in
        let generators = Listq.unique generators in
        let prev = polygraph (prev f) (p_prev p) in
        p_create ~generators ~prev ()

    (** Co-domain of a morphism *)
    let rec codomain f =
      if dim f < 0 then p_dummy else
        let generators = Mapq.codomain (map f) in
        let prev = codomain (prev f) in
        p_create ~generators ~prev ()

    (** Image of a cell. *)
    let rec cell f c =
      assert (dim f = c_dim c);
      if dim f < 0 then c_dummy else
        let source = cell (prev f) (c_source c) in
        let target = cell (prev f) (c_target c) in
        let source_morphism = c_source_morphism c in
        let target_morphism = c_target_morphism c in
        let label = seq (c_label c) f in
        c_create ~label ~source ~source_morphism ~target ~target_morphism ()

    (** Operations on partially defined morphisms. *)
    module Partial = struct
      (* We should hide the fact that this is implemented as morphism. *)
      type t =
          {
            source : polygraph;
            target : polygraph;
            map : (generator, generator) Mapq.t;
            prev : t;
          }

      let source f = f.source
      let target f = f.target
      let dim f = p_dim (source f)
      let map f = f.map
      let prev f = f.prev

      let rec dummy =
        {
          source = p_dummy;
          target = p_dummy;
          map = Mapq.empty;
          prev = dummy;
        }

      let create ~map ~prev ~source ~target () =
        assert (p_dim source = p_dim target);
        { source; target; map; prev }

      let rec to_string uid f =
        if dim f < 0 then "" else
          (map_to_string uid (map f)) ^ "\n" ^ to_string uid (prev f)

      let rec total f =
        if dim f < 0 then m_dummy else
          (
            assert (Listq.included (generators (source f)) (Mapq.domain (map f)));
            let prev = total (prev f) in
            m_create ~map:(map f) ~prev ~source:(source f) ~target:(target f) ()
          )

      let rec app f g =
        assert (G.dim g <= dim f);
        if G.dim g = dim f then Mapq.app (map f) g
        else app (prev f) g

      (** Nowhere defined morphism. *)
      let rec empty ~source ~target () =
        assert (p_dim source = p_dim target);
        let dim = p_dim source in
        if dim < 0 then dummy else
          let prev = empty ~source:(p_prev source) ~target:(p_prev target) () in
          let map = Mapq.empty in
          create ~source ~target ~map ~prev ()

      (** Add a binding. *)
      let rec add f g1 g2 =
        assert (G.dim g1 = G.dim g2);
        assert (G.dim g1 <= dim f);
        assert (memd (source f) g1);
        assert (memd (target f) g2);
        if G.dim g1 = dim f then
          if Mapq.mem (map f) g1 then (assert (g1 == g2); f)
          else
            let fmap = Mapq.add (map f) g1 g2 in
            create ~source:(source f) ~target:(target f) ~map:fmap ~prev:(prev f) ()
        else
          let prev = add (prev f) g1 g2 in
          create ~source:(source f) ~target:(target f) ~map:(map f) ~prev ()

      (** Is a generator in the domain? *)
      let rec mem f g =
        assert (g_dim g <= dim f);
        assert (g_dim g >= 0);
        if g_dim g = dim f then
          Mapq.mem (map f) g
        else
          mem (prev f) g

      let rec surjective f =
        if dim f < 0 then true else
          surjective (prev f) && Listq.included (generators (target f)) (Mapq.codomain (map f))
              (*
      let rec compatible f1 f2 =
        assert (dim f1 = dim f2);
        if dim f1 < 0 then true else
          Mapq.compatible (map f1) (map f2) && compatible (prev f1) (prev f2)

      let rec union f1 f2 =
        assert (dim f1 = dim f2);
        assert (p_eq (source f1) (source f2));
        assert (p_eq (target f1) (target f2));
        if dim f1 < 0 then dummy else
          let map = Mapq.union (map f1) (map f2) in
          let prev = union (prev f1) (prev f2) in
          create ~source:(source f1) ~target:(target f1) ~map ~prev ()
               *)
    end
    module PM = Partial

    (*
    (** Categorical morphisms, sending generators to cells. *)
    module Categorical = struct
      type t =
          {
            map : (generator, cell) Mapq.t;
            prev : t;
            source : polygraph;
            target : polygraph;
          }
      type c_morphism = t

      let rec dummy =
        {
          map = Mapq.empty;
          prev = dummy;
          source = p_dummy;
          target = p_dummy
        }

      let map f = f.map
      let prev f = f.prev
      let source f = f.source
      let target f = f.target

      let dim f = p_dim (source f)

      let create ~map ~prev ~source ~target () =
        assert (p_dim source = p_dim target);
        assert (p_dim source = dim prev + 1);
        { map; prev; source; target }

      let app f g =
        assert (G.dim g = dim f);
        Mapq.app (map f) g

      (** Partial categorical morphisms. Those are useful in order to perform
      substitutions. *)
      module Partial = struct
        type t = c_morphism
        let dummy = dummy
        let map = map
        let prev = prev
        let source = source
        let target = target
        let dim = dim
        let create = create

        let rec app f g =
          assert (G.dim g <= dim f);
          if dim f > G.dim g then
            app (prev f) g
          else
            Mapq.app (map f) g

        let mem f g =
          assert (G.dim g <= dim f);
          let rec aux f =
            if dim f > G.dim g then aux (prev f)
            else
              Mapq.mem (map f) g
          in
          aux f

        (** Substitute in a polygraph. This returns a partial (non-categorical)
        morphism witnessing how generators a renamed. *)
        let rec subst f p =
          assert (dim f = p_dim p);
          if p_dim p < 0 then PM.dummy else
            let prev = subst (prev f) (p_prev p) in
            let generators = generators p in
            let generators = List.filter (fun g -> not (mem f g)) generators in
            let genreators = (p_generators p)@generators in
            (* TODO: substitute in the border of generators *)
            let p' = p_create ~generators ~prev:(PM.target prev) () in
            (* TODO! *)
            PM.empty ~source:p ~target:p' ()
      end
    end
    *)
  end
  module M = Morphism

  (** Equivalence relation on generators. *)
  module Quotient = struct
    type t =
        {
          domain : polygraph; (** polygraph on which the equivalence is taken *)
          equiv : generator Equivq.t;
          prev : t;
        }

    let domain r = r.domain

    let dim r = dim (domain r)

    let equiv r = r.equiv

    let prev r = r.prev

    let create ~polygraph ~equiv ~prev () =
      assert (p_dim polygraph = dim prev + 1);
      { domain = polygraph; equiv; prev; }

    let rec dummy =
      {
        domain = p_dummy;
        equiv = Equivq.empty;
        prev = dummy;
      }

    let rec to_string uid r =
      if dim r < 0 then "" else
        to_string uid (prev r) ^ map_to_string uid (Equivq.map (equiv r)) ^ "\n"

    (** Canonical representative of a generator. *)
    let repr r g =
      assert (dim r = G.dim g);
      Equivq.repr (equiv r) g

    let degenerate ?polygraph r =
      let polygraph = Option.default (degenerate (domain r)) polygraph in
      let equiv = List.fold_left Equivq.add Equivq.empty (generators polygraph) in
      create ~polygraph ~equiv ~prev:r ()

    (** Identify two generators. *)
    let rec add r g1 g2 =
      assert (dim r = G.dim g1);
      assert (dim r = G.dim g2);
      assert (Listq.mem g1 (generators (domain r)));
      assert (Listq.mem g2 (generators (domain r)));
      let prev = prev r in
      let equiv = equiv r in
      let g = G.create ~name:(G.name g1) ~source:(cell prev (G.source g1)) ~target:(cell prev (G.target g1)) () in
      let equiv = Equivq.add equiv g in
      let equiv = Equivq.relate equiv g1 g in
      let equiv = Equivq.relate equiv g2 g in
      create ~polygraph:(domain r) ~equiv ~prev ()

    (** Quotient a cell. *)
    and cell r c =
      assert (dim r = c_dim c);
      if dim r < 0 then c_dummy else
        let p = M.target (c_label c) in
        let q = polygraph r p in
        let label = M.seq (c_label c) q in
        let source = cell (prev r) (c_source c) in
        let source_morphism = c_source_morphism c in
        let target = cell (prev r) (c_target c) in
        let target_morphism = c_target_morphism c in
        c_create ~label ~source ~source_morphism ~target ~target_morphism ()

    (** Quotient morphism of a polygraph under an equivalence relation. *)
    and polygraph r p =
      assert (dim r = p_dim p);
      if dim r < 0 then M.dummy else
        let prev = polygraph (prev r) (p_prev p) in
        let map = Listq.map (fun g -> g, repr r g) (p_generators p) in
        let target =
          let generators = List.map snd map in
          let generators = Listq.unique generators in
          let prev = M.target prev in
          p_create ~generators ~prev ()
        in
        let map = GMap.of_list map in
        M.create ~map ~prev ~source:p ~target ()
    let polygraph r =
      polygraph r (domain r)
  end
  module Q = Quotient

  (** Inclusion coresponding to adding a generator (see [add]). *)
  let iadd p g =
    let p' = add p g in
    M.inclusion p p'

  (** Copy a polygraph. It provides the corresponding isomorphism. *)
  (*
  let rec copy p =
    (* Printf.printf "COPY:\n%s\n%!" (to_string uidebug p); *)
    let rec equiv p =
      if dim p < 0 then Q.dummy else
        let prev = equiv (prev p) in
        List.fold_left (fun r g -> Q.add r g g) (Q.degenerate prev) (generators p)
    in
    Q.polygraph (equiv p) p
  *)
  let rec copy p =
    (* Printf.printf "COPY:\n%s\n%!" (to_string ~tab:1 uidebug p); *)
    if dim p < 0 then M.dummy else
      let prev = copy (prev p) in
      let g_copy g =
        let name = G.name g in
        let source = M.cell prev (G.source g) in
        let target = M.cell prev (G.target g) in
        G.create ~name ~source ~target ()
      in
      let map = Listq.map (fun g -> g, g_copy g) (generators p) in
      let target =
        let generators = List.map snd map in
        let prev = M.target prev in
        create ~generators ~prev ()
      in
      let map = GMap.of_list map in
      M.create ~map ~prev ~source:p ~target ()
  (* let copy p = *)
    (* let f = copy p in *)
    (* Printf.printf "COPY OF\n%sIS\n%s\n%!" (to_string uidebug p) (to_string uidebug (M.target f)); *)
    (* f *)

  (** Coproduct. *)
  let coprod p1 p2 =
    assert (dim p1 = dim p2);
    let f1 = copy p1 in
    let f2 = copy p2 in
    let p = union (M.target f1) (M.target f2) in
    let i1 = M.inclusion (M.target f1) p in
    let i2 = M.inclusion (M.target f2) p in
    M.seq f1 i1, M.seq f2 i2

  (** Coequalizer. *)
  let coeq f1 f2 =
    (* Printf.printf "COEQ:\n%s\n%!" (to_string uidebug (M.target f1)); *)
    assert (M.dim f1 = M.dim f2);
    assert (eq (M.source f1) (M.source f2));
    assert (eq (M.target f1) (M.target f2));
    let rec equiv f1 f2 =
      if M.dim f1 < 0 then Q.dummy else
        let r = equiv (M.prev f1) (M.prev f2) in
        let r = Q.degenerate ~polygraph:(M.target f1) r in
        let r = List.fold_left (fun r g -> Q.add r (M.app f1 g) (M.app f2 g)) r (generators (M.source f1)) in
        (* This is necessary in order to send non-quotiented generators to
        copies with normal forms as source and target. *)
        List.fold_left (fun r g -> Q.add r g g) r (generators (M.target f1))
    in
    let r = equiv f1 f2 in
    let p = M.target f1 in
    Q.polygraph r
  (* let coeq f1 f2 = *)
  (* let q = coeq f1 f2 in *)
  (* Printf.printf "COEQ OF\n%sIS\n%s\n%!" (to_string uidebug (M.target f1)) (to_string uidebug (M.target q)); *)
  (* q *)

  (** Pushout of two maps. *)
  let pushout f1 f2 =
    (* Printf.printf "PUSHOUT:\n%sAND\n%s%!" (to_string uidebug (M.target f1)) (to_string uidebug (M.target f2)); *)
    assert (M.dim f1 = M.dim f2);
    assert (eq (M.source f1) (M.source f2));
    let i1, i2 = coprod (M.target f1) (M.target f2) in
    let g = coeq (M.seq f1 i1) (M.seq f2 i2) in
    M.seq i1 g, M.seq i2 g

  (** Pushout of four maps. *)
  let bipushout (f1,f2) (g1,g2) =
    assert (M.dim f1 = M.dim f2 && M.dim f2 = M.dim g1 && M.dim g1 = M.dim g2);
    assert (eq (M.source f1) (M.source f2));
    assert (eq (M.source g1) (M.source g2));
    assert (eq (M.target f1) (M.target g1));
    assert (eq (M.target f2) (M.target g2));
    let a = M.source f1 in
    let c = M.source g1 in
    let ia,ic = coprod a c in
    let h1 = M.coprod f1 (ia,ic) g1 in
    let h2 = M.coprod f2 (ia,ic) g2 in
    pushout h1 h2
  (* let bipushout (f1,f2) (g1,g2) = *)
  (* let i1,i2 = bipushout (f1,f2) (g1,g2) in *)
  (* Printf.printf "BIPUSHOUT OF\n%sAND\n%sIS\n%s\n%!" (to_string uidebug (M.target f1)) (to_string uidebug (M.target f2)) (to_string uidebug (M.target i1)); *)
  (* i1,i2 *)
end
module P = Polygraph

module Morphism = Polygraph.Morphism
module M = Morphism
module PM = Morphism.Partial

(** Operations on cells. *)
module Cell = struct
  type t = cell

  let dim = c_dim

  let polygraph = c_polygraph

  let label = c_label

  let source = c_source

  let source_morphism = c_source_morphism

  let target = c_target

  let target_morphism = c_target_morphism

  (** Generators occurring in a cell. *)
  let generators c = P.generators (polygraph c)

  let dummy = c_dummy

  (** Create a cell. *)
  let create = c_create

  (** String representation of a cell. *)
  let to_string = c_to_string

  (** Create a 0-cell corresponding to a 0-generator of a polygraph. *)
  let create_zero_cell p g =
    assert (G.dim g = 0);
    let g0 = G.create ~name:(G.name g) ~source:dummy ~target:dummy () in
    let polygraph = P.add (P.degenerate P.dummy) g0 in
    let label =
      let map = GMap.of_list [g0,g] in
      M.create ~map ~prev:M.dummy ~source:polygraph ~target:p ()
    in
    let f = M.inclusion (P.degenerate P.dummy) polygraph in
    create ~label ~source:dummy ~source_morphism:f ~target:dummy ~target_morphism:f ()

  (** k-th source morphism. *)
  let rec source_k_morphism k c =
    assert (k >= 0);
    if k = 0 then M.id (polygraph c)
    else if k = 1 then source_morphism c
    else M.seq (M.degenerate (source_k_morphism (k-1) (source c))) (source_morphism c)

  (** k-th target morphism. *)
  let rec target_k_morphism k c =
    assert (k >= 0);
    if k = 0 then M.id (polygraph c)
    else if k = 1 then target_morphism c
    else M.seq (M.degenerate (target_k_morphism (k-1) (target c))) (target_morphism c)

  (** Identity cell in a given signature polygraph. *)
  let id p c =
    assert (P.dim p = dim c + 1);
    assert (P.eq (P.prev p) (M.target (label c)));
    let label = M.seq (M.degenerate (label c)) (M.inclusion (P.degenerate (M.target (label c))) p) in
    let f = M.id (M.source label) in
    create ~label ~source:c ~source_morphism:f ~target:c ~target_morphism:f ()

  (** (Approximation of) equality between cells. *)
  let eq c1 c2 =
    c1 == c2 || P.eq (polygraph c1) (polygraph c2)

  (** Cell corresponding to a generator. *)
  let of_generator p g =
    Printf.printf "OF_GENERATOR: %s\n\n%!" (G.to_string uidebug g);
    assert (P.dim p = G.dim g);
    assert (Listq.mem g (P.generators p));
    let signature = p in
    if G.dim g = 0 then
      create_zero_cell p g
    else
      let s = G.source g in
      let t = G.target g in
      let iss = source_morphism s in
      let ist = source_morphism t in
      let its = target_morphism s in
      let itt = target_morphism t in
      let is,it = P.bipushout (iss,ist) (its,itt) in
      let polygraph = P.degenerate (M.target is) in
      let g0 =
        let rec c_relabel c f =
          assert (dim c = M.dim f);
          if dim c < 0 then dummy else
            let source = c_relabel (source c) (M.prev (M.seq (source_morphism c) f)) in
            let target = c_relabel (target c) (M.prev (M.seq (target_morphism c) f)) in
            let source_morphism = source_morphism c in
            let target_morphism = target_morphism c in
            create ~label:f ~source ~source_morphism ~target ~target_morphism ()
        in
        let source = c_relabel s is in
        let target = c_relabel t it in
        G.create ~name:(G.name g) ~source ~target ()
      in
      let j = P.iadd polygraph g0 in
      let polygraph = M.target j in
      let label =
        let map = GMap.of_list [g0,g] in
        let prev = M.bipushout (label s) (is,it) (label t) in
        M.create ~map ~prev ~source:polygraph ~target:signature ()
      in
      (* Printf.printf "polygraph:\n%s\n%!" (P.to_string uidebug polygraph); *)
      (* Printf.printf "label:\n%s\n%!" (M.to_string uidebug label); *)
      create ~label ~source:s ~target:t ~source_morphism:(M.seq (M.degenerate is) j) ~target_morphism:(M.seq (M.degenerate it) j) ()

  let list_of_one_cell = c_list_of_one_cell

  exception Mismatch
  exception Not_unique

  (** Find a canonical isomorphism between two cells. Notice that this cannot be
  done in general. *)
  let rec unify c1 c2 =
    if dim c1 > 0 then Printf.printf "UNIFY\n%s\nWITH\n%s\n\n%!" (to_string ~human:false uidebug c1) (to_string ~human:false uidebug c2);
    if dim c1 >= 0 then Printf.printf "UNIFY\n%s\nWITH\n%s\n\n%!" (to_string uidebug c1) (to_string uidebug c2);

    (* Injections from a list to another one. *)
    let rec injections ls lt =
      match ls with
      | x::ls ->
         List.flatten
           (
             List.map_context
               (fun h y t ->
                let ii = injections ls (h@t) in
                List.map (fun i -> (x,y)::i) ii
               ) lt
           )
      | [] -> [[]]
    in
    (* Given an unifier and maps, generate the unifications obtained as
    images. *)
    let rec uapp f1 f2 u =
      assert (P.eq (M.source u) (M.source f1));
      assert (P.eq (M.target u) (M.source f2));
      if M.dim u < 0 then [] else
        let prev = uapp (M.prev f1) (M.prev f2) (M.prev u) in
        let l = Mapq.to_list (M.map u) in
        let l = List.map (fun (g1,g2) -> M.app f1 g1, M.app f2 g2) l in
        l@prev
    in
    (* We want smallest generators first. *)
    let uapp u f1 f2 = List.rev (uapp u f1 f2) in

    assert (dim c1 = dim c2);
    if dim c1 < 0 then [M.dummy] else

      (* unfier / generators to unify queue *)
      let rec aux (u,q) =
        Printf.printf "AUX (%d)\n%!" (List.length q);
        match q with
        | [] ->
           (* TODO: more unification in the case where the unifier is not total *)
           assert (PM.surjective u);
           [PM.total u]
        | (g1,g2)::q ->
           Printf.printf "%s =?= %s\n%!" (G.to_string uidebug g1) (G.to_string uidebug g2);
           if PM.mem u g1 then
             if PM.app u g1 != g2 then [] else aux (u,q)
           else
             let s1 = G.source g1 in
             let s2 = G.source g2 in
             let t1 = G.target g1 in
             let t2 = G.target g2 in
             let uu1 = unify s1 s2 in
             let uu2 = unify t1 t2 in
             List.bind
               (fun u1 ->
                List.bind
                  (fun u2 ->
                   (* TODO: ensure that u1 and u2 satisfy globular relations *)
                   let l1 = uapp (label s1) (label s2) u1 in
                   let l2 = uapp (label t1) (label t2) u2 in
                   let q = l1@l2@q in
                   let u = PM.add u g1 g2 in
                   aux (u,q)
                  ) uu2
               ) uu1
      in
      let u = PM.empty ~source:(polygraph c1) ~target:(polygraph c2) () in
      let uu = List.bind (fun inj -> aux (u,inj)) (injections (generators c1) (generators c2)) in
      List.iter (fun u -> if dim c1 > 0 then Printf.printf "FOUND\n%s\n%!" (M.to_string uidebug u)) uu;
      Printf.printf "UNIFIERS: %d\n%!" (List.length uu);
      (* assert (List.length uu = 1); *)
      (* List.hd uu *)
      uu

  let unify c1 c2 =
    let rec valid u =
      if M.dim u < 0 then true else
        List.for_all (fun (g1,g2) -> M.appd (label c1) g1 == M.appd (label c2) g2) (Mapq.to_list (M.map u))
        && valid (M.prev u)
    in
    List.filter valid (unify c1 c2)

  let identify c1 c2 =
    let uu = unify c1 c2 in
    assert (List.length uu = 1);
    List.hd uu

  (*
  (** Find a canonical isomorphism between two cells. *)
  let identify c1 c2 =
    (* Printf.printf "IDENTIFY %d\n%!" (dim c1); *)
    assert (dim c1 = dim c2);
    (* TODO: we should be able to remove the base cases *)
    match dim c1 with
    | 0 ->
       let g1 = List.element (generators c1) in
       let g2 = List.element (generators c2) in
       if M.app (label c1) g1 != M.app (label c2) g2 then raise Not_found;
       let map = GMap.of_list [g1,g2] in
       M.create ~map ~prev:M.dummy ~source:(polygraph c1) ~target:(polygraph c2) ()
    | 1 ->
       let lab1' = M.app (M.prev (label c1)) in
       let lab2' = M.app (M.prev (label c2)) in
       let lab1 = M.app (label c1) in
       let lab2 = M.app (label c2) in
       let s1, l1 = list_of_one_cell c1 in
       let s2, l2 = list_of_one_cell c2 in
       if List.length l1 <> List.length l2 then raise Not_found;
       if lab1' s1 != lab2' s2 then raise Not_found;
       let f0 = (s1,s2)::(List.map2 (fun (_,t1) (_,t2) -> if lab1' t1 != lab2' t2 then raise Not_found; t1, t2) l1 l2) in
       let f1 = List.map2 (fun (g1,_) (g2,_) -> if lab1 g1 != lab2 g2 then raise Not_found; g1, g2) l1 l2 in
       let f0 = GMap.of_list f0 in
       let f1 = GMap.of_list f1 in
       let f0 = M.create ~map:f0 ~prev:M.dummy ~source:(P.prev (polygraph c1)) ~target:(P.prev (polygraph c2)) () in
       let f1 = M.create ~map:f1 ~prev:f0 ~source:(polygraph c1) ~target:(polygraph c2) () in
       f1
    | _ ->
       failwith "TODO"
    *)

  (** Composition, given in computer-scientific order. *)
  let rec seqm d c1 c2 =
    (* Printf.printf "SEQ %d:\n%sWITH\n%s\n%!" d (to_string ~tab:1 uidebug c1) (to_string ~tab:1 uidebug c2); *)
    assert (dim c1 = dim c2);
    assert (0 <= d && d < dim c1);
    let k = dim c1 - d in
    let f = identify (iterate k target c1) (iterate k source c2) in
    let i1, i2 =
      P.pushout
        (target_k_morphism k c1)
        (M.seq (iterate k M.degenerate f) (source_k_morphism k c2))
    in
    let label = M.pushout (label c1) (i1,i2) (label c2) in
    let source, source_morphism =
      if k = 1 then source c1, M.seq (source_morphism c1) i1
      else
        let is1, s, is2 = seqm d (source c1) (source c2) in
        s, M.pushout (M.seq (source_morphism c1) i1) (M.degenerate is1, M.degenerate is2) (M.seq (source_morphism c2) i2)
    in
    let target, target_morphism =
      if k = 1 then target c2, M.seq (target_morphism c2) i2
      else
        let it1, t, it2 = seqm d (target c1) (target c2) in
        t, M.pushout (M.seq (target_morphism c1) i1) (M.degenerate it1, M.degenerate it2) (M.seq (target_morphism c2) i2)
    in
    i1, create ~label ~source ~source_morphism ~target ~target_morphism (), i2

  (** Simple version of [seqm], not returning inclusions morphisms. *)
  let seq d c1 c2 =
    let _,c,_ = seqm d c1 c2 in
    c

  (*
  (** Compute minimal generators of a cell. *)
  let minimal_generators c =
    assert (generators c <> []);
    let rec filter source source_morphism generators =
      assert (P.dim source = M.dim source_morphism);
      let d = P.dim source in
      let k = dim c - d in
      if d < 0 then generators else
        let generators = filter (P.prev source) (M.prev source_morphism) generators in
        let source_generators = List.map (M.app source_morphism) (P.generators source) in
        List.filter
          (fun g ->
           let src = G.source g in
           let gsrc = P.generators (iterate (k-1) P.prev (polygraph src)) in
           let gsrc = List.map (M.app (iterate (k-1) M.prev (label src))) gsrc in
           Listq.included gsrc source_generators
          ) generators
    in
    filter (polygraph (source c)) (M.prev (source_morphism c)) (generators c)

  let minimal_generator c =
    List.hd (minimal_generators c)

  (** Remove a minimal generator in a cell. *)
  let remove_minimal_generator c g =
    let csource = source c in
    let psource = polygraph csource in
  *)
end
module C = Cell

(** Operations on track polygraphs. *)
module Track = struct
  (** A track polygraph. *)
  type t =
      {
        level : int; (** dimension from which the cells are invertible (level is included) *)
        involution : M.t; (** involution sending a cell to its inverse *)
      }

  (** Dimension from which cells are invertible (level is included). *)
  let level t = t.level

  let involution t = t.involution

  let polygraph t = M.source (involution t)

  let dim t = M.dim (involution t)

  (** Is a generator invertible? *)
  let invertible t g =
    G.dim g >= level t

  let inverse t g =
    assert (invertible t g);
    M.app (involution t) g

  let create ~level ~involution () =
    assert (M.source involution == M.target involution);
    (* TODO: ensure that involution is involutive *)
    { level; involution }

  let prev t =
    create ~level:(level t) ~involution:(M.prev (involution t)) ()

  (** Free track polygraph over a polygraph. *)
  let of_polygraph level p =
    let rec invert p =
      if P.dim p < level then M.id p else
        let f' = invert (P.prev p) in
        let g_invert g = G.create ~name:(G.name g^"-") ~source:(G.target g) ~target:(G.source g) () in
        let generators = P.generators p in
        let map = List.map (fun g -> g, g_invert g) generators in
        let generators_inv = List.map snd map in
        let p = P.create ~generators:(generators@generators_inv) ~prev:(M.source f') () in
        let map = map@(List.map Pair.swap map) in
        let map = GMap.of_list map in
        let f = M.create ~map ~prev:f' ~source:p ~target:p () in
        f
    in
    let involution = invert p in
    create ~level ~involution ()

  (** Inverse of a generator. *)
  let inverse t g =
    assert (invertible t g);
    M.app (involution t) g

  (** Remove a generator (along with its inverse). This function should not be
  used directly unless you know what you are doing: [reduce] should be used to
  safely perform homotopical reduction *)
  let remove t g =
    assert (G.dim g <= dim t);
    (* Remove generators from involution *)
    let rec rm f gg =
      let dimg = if gg = [] then -1 else G.dim (List.hd gg) in
      assert (List.for_all (fun g -> G.dim g = dimg) gg);
      assert (dimg <= M.dim f);
      if gg = [] then f else
        if M.dim f > dimg then
          let prev = rm (M.prev f) gg in
          let p = P.create ~generators:(P.generators (M.source f)) ~prev:(M.source prev) () in
          M.create ~map:(M.map f) ~prev ~source:p ~target:p ()
        else
          let prev = M.prev f in
          let p = M.source f in
          let generators = List.filter (fun g' -> not (Listq.mem g' gg)) (P.generators p) in
          let p = P.create ~generators ~prev:(P.prev p) () in
          let map = Mapq.restrict generators (M.map f) in
          M.create ~map ~prev:(M.prev f) ~source:p ~target:p ()
    in
    let gg = if invertible t g then [g; inverse t g] else [g] in
    let involution = rm (involution t) gg in
    create ~level:(level t) ~involution ()

  (** Perform homotopical reduction of the source of a generator through the
  generator. *)
  let reduce t g =
    assert (G.dim g <= dim t);
    let p = polygraph t in
    let cg = C.of_generator p g in
    let pg = C.polygraph cg in
    let pgs = M.codomain (C.source_morphism cg) in
    let is = M.inclusion pgs pg in
    let gs = List.element (P.generators (P.prev pgs)) in
    (* TODO: ensure that gs does not occur in target *)
    (* TODO: degenerate pg and pgs *)
    let t = remove t g in
    (* let uu = *)
    ()
end
module TP = Track


let () =
  if true then
    (
      Printexc.record_backtrace true;
      let uid = uidebug in
      let p0 = P.degenerate P.dummy in
      let star = G.create ~name:"✶" ~source:C.dummy ~target:C.dummy () in
      let p0 = P.add p0 star in
      Printf.printf "p0:\n%s\n%!" (P.to_string uid p0);
      let star_c = C.of_generator p0 star in
      Printf.printf "star_c:\n%s\n\n%!" (C.to_string uid star_c);
      let p1 = P.degenerate p0 in
      let one = G.create ~name:"a" ~source:star_c ~target:star_c () in
      let p1 = P.add p1 one in
      Printf.printf "p1:\n%s\n%!" (P.to_string uid p1);
      let one_c = C.of_generator p1 one in
      Printf.printf "one_c:\n%s\n\n%!" (C.to_string ~human:true uid one_c);
      let p2 = P.degenerate p1 in
      let two_c = C.seq 0 one_c one_c in
      Printf.printf "two_c:\n%s\n%!" (C.to_string ~human:false uid two_c);
      Printf.printf "two_c:\n%s\n%!" (C.to_string ~human:true uid two_c);
      let mu = G.create ~name:"µ" ~source:(C.seq 0 one_c one_c) ~target:one_c () in
      let p2 = P.add p2 mu in
      let eta = G.create ~name:"η" ~source:(C.id p1 star_c) ~target:one_c () in
      let p2 = P.add p2 eta in
      Printf.printf "p2:\n%s\n%!" (P.to_string uid p2);
      let mu_c = C.of_generator p2 mu in
      Printf.printf "mu_c:\n%s\n%!" (C.to_string ~human:false uid mu_c);
      Printf.printf "mu_c:\n%s\n%!" (C.to_string ~human:true uid mu_c);
      let mu_id_c = C.seq 0 mu_c (C.id p2 one_c) in
      Printf.printf "mu_id_c:\n%s\n%!" (C.to_string ~human:false uid mu_id_c);
      Printf.printf "mu_id_c:\n%s\n%!" (C.to_string ~human:true uid mu_id_c);
      let mumu = C.seq 1 mu_id_c mu_c in
      Printf.printf "mumu:\n%s\n%!" (C.to_string ~human:false uid mumu);
      Printf.printf "mumu:\n%s\n%!" (C.to_string ~human:true uid mumu);
      let eta_c = C.of_generator p2 eta in
      Printf.printf "eta_c:\n%s\n%!" (C.to_string uid eta_c);
      let id_one = C.id p2 one_c in
      Printf.printf "id_one:\n%s\n%!" (C.to_string uid id_one);
      let etaid = C.seq 0 eta_c id_one in
      Printf.printf "etaid:\n%s\n%!" (C.to_string uid etaid);
      let left = C.seq 1 etaid mu_c in
      Printf.printf "left:\n%s\n%!" (C.to_string uid left);
      (* Printf.printf "mg left:\n%s\n%!" (G.to_string uid (C.minimal_generator left)); *)
      let mumumu = C.seq 1 (C.seq 0 mu_c mu_c) mu_c in
      Printf.printf "mumumu:\n%s\n%!" (C.to_string uid mumumu);
      (* Printf.printf "minimal: %d\n%!" (List.length (C.minimal_generators mumumu)); *)
      ()
    )
